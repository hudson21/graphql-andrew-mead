==================================== Reasons to use GraphQL ==================================================

1. GraphQL is fast
2. graphQLis flexible
3. graphQL is easy to use at simple to maintain

==================================== Visual Studio Code Plugins =============================================
Babel ES6/ES7
Beautify
Docker 
Duplicate action
GraphQL for VSCode
npm 
npm intellisense
Sublime Text Keymap
Word Count 

==================================== What is GraphQL ========================================================
graphql-demo.mead.io

Three Main Operations in GraphQL:
    1. Queries (getting data)
    2. Mutations (changing actions like update, deete and insert)
    3. Subscriptions (watchers)

First Query:

query {
    hello --> first query
    courseInstructor --> second query
    course --> Third Query
}

==================================== 8. Nestes GraphQL Queries ========================================================
query {
    me {
        id 
        name
        email
    }
}

query {
    users { --> this returns an array of users
        name
    }
}

query {
    posts {
      id
      title
      body
      published
      author {
        id
        name
        email
      }
      comments {
        id
        text
        post {
          id
          title
        }
      }
    }
}

==================================== 9. Setting up Babel ========================================================
Babeljs.io
cmder.net --> To use the same commands as Mac or Linux OS 

Toggle Terminal --> Look for it in the VS Code Command Line

npm install babel-cli@6.26.0 babel-preset-env@1.7.0 

==================================== 10. Import Export ========================================================

==================================== 11. Creating your own graphQL API ========================================
facebook.github.io/graphql

npm install graphql-yoga@1.14.10

https://github.com/prisma/graphql-yoga

graphql-toga will set the server in localhost:4000

==================================== 12. GraphQL Scalar Types ========================================
Five Scalar Types:
    1. String
    2. Boolean
    3. Int
    4. Float
    5. ID

==================================== 13. Live Reload for GraphQL ========================================
npm install nodemon --save-dev


==================================== 15. Operation Arguments ========================================
GraphQL Arguments: parent, args, ctx, info

greeting(parent, args, ctx, info) {
    if (args.name && args.position) {
        return `Hello ${args.name}!. You are my favorite ${args.position}`
    } else {
        return 'Hello!'
    }
},

add(parent, args, ctx, info) {
    return args.a + args.b
},


users {
    id
    name
    email
    age
    posts {
      id
      title
      body
      published
    }
  }

posts {
    id
    title
    body
    published
    author {
      id
      name
      email
      age
    }
  }

npm install uuid

v1, v3, v4, v5



mutation {
  createUser(name:"Carlos Hudson", email:"carlosmigu27@hotmail.com") {
    id
    name
    email
  }
}


========================================= Object Spread Operator ========================================================

npm install babel-plugin-transform-object-rest-spread

everything inside of the input type needs to be scalar (not custom objects)

input CreateUserInput {
    name: String! 
    email: String! 
    age: Int
}

mutation {
  createUser(
    data: {
      name:"Carlos Hudson", 
      email:"carlosmigu27@hotmail.com"
    }
  ) {
    id
    name
    email
  }
}


-----> nodemon 
  Specifying extension watch list
In package.json:
nodemon src/index.js --ext js,graphql --exec babel-node

==================================  Subscriptions ================================================
Subscriptions use websockets in order to update instantly the data which is being fetched

================================== Enums =========================================================
Enum: (Enumeration)
  1. A special type that defines a set of constants
  2. This type can then be used as the type for a field (similat to scalar and custom object types)
  3. Values for the field must be one of the constants for the type

Example: 
  UserRole --> standard, editor, admin


=========================================== Prima =================================================
What is Prisma ? 
 
Native Drivers are tools to get connected with the database in the server (backend)
ORM (Object Relational Mapping) --> (Sequelize, Mongoose)

Prisma (GraphQL ORM)

=========================================== Prisma Setup (Windows) ====================================
Getting a PostgreSQL database in Heroku:
  1. Create a new Project
  2. Go to the overview tab once the new project is created
  3. Click on Configure Addons
  4. Look for heroku postgres in the searching bar
  5. Settings Tab once the database is created
  6. Click on view credentials
Install PgAdmin on your Windows Machine (In my case I prefer to user datagrip)

Install Docker
    1. www.docker.com
    2. Download Docker Toolbox
    3. Docker Address on the Operative System: 192.168.99.100

prisma.io 
  npm install -g prisma
  Inside of the root project use `prisma init name-of-the-project` (in graphql-prisma folder)
    1. Use existing database (In this case the postgresql database generated in heroku)
    2. PostgreSQL
    3. No

1. cd prisma
2. docker-compose up -d
3. prisma deploy --> deploy de datamodel inside of the prisma folder

another commands: 
1. docker ps 
2. docker logs prisma_prisma_1

********************************* IMPORTANT TO SEE ********************************************************************************
This happened to me when using Docker Toolbox on Windows 10, the endpoint had to be changed from using localhost to the VirtualBox default ip within prisma.yml:

endpoint: http://192.168.99.100:4466

*********************** GraphQL Directives ***************************
@unique --> A given field must be unique


------------------------- Example of a mutation using Prisma --------------------------------------

mutation {
  createPost(data: {
    title: "My First Post",
    body: "Body of the First Post",
    published: true
    author: {
      connect: {
        id: "ck14a8wx200090778jovxw30k"
      }
    }
  }) {
    id
    title
    body
    published
    author {
      email
      name
    }
  }
}


mutation {
  createComment(data: {
    text: "The first post is amazing :)",
    author: {
      connect: {
        id: "ck14bq9ce00350778ie208omz"
      }
    },
    post: {
      connect: {
        id: "ck14ay7l6001v0778h42mmg1a"
      }
    }
  }) {
    id
    text
    author {
			id
      name
      email
  	}
  }
}


********************************** Integrating Node.js with Prisma ****************************************
+prisma-binding --> to connect with Node.js

npm install prisma-binding

+graphql-cli
the command we care inside of this library is: `graphql get-schema`

npm install graphql-cli

console.log(JSON.stringify(data, undefined, 2)); // Example of JSON.stringify

-------------------> Examples using prisma-binding in Node.js

// callbacks, promises, async await

//prisma.query, prisma.mutation, prisma.subscription, prisma.exists

//first argument: operational argument
//second argument: selection set (the fields you wanna see in the graphql results)

/*prisma.query.users(null, '{ id name posts { id title } }').then((data) => {
    console.log("users", JSON.stringify(data, undefined, 2));
})*/

/*prisma.query.comments(null, '{ id text author { id name } }').then((data) => {
    console.log("comments", JSON.stringify(data, undefined, 2));
})*/

//1. Create a new Post
//2. Fetch all of the info about the user (author)

/*prisma.exists.Comment({
    id: 'ck14c8y1a003w0778egikdjsw',
    author: {
        id: 'ck14bq9ce00350778ie208omz'
    }
}).then(exists => {
    console.log(exists)
})*/

const createPostForUser = async (authorId, data) => {
    const userExists = await prisma.exists.User({ id: authorId })

    if (!userExists) {
        throw new Error ('User not found')
    } 

    const post = await prisma.mutation.createPost({
        data: {
            ...data,
            author: {
                connect: {
                    id: authorId
                }
            }
        }
    }, '{ author { id name email posts { id title published } } }')
    return post.author
}

/*createPostForUser('ck14bq9ce00350778ie208omz', {
    title: 'New Post',
    body: 'This is the body of the New Post',
    published: false
}).then(user => console.log(JSON.stringify(user, undefined, 2)))
.catch(error => console.log(error))*/


const updatePostForUser = async (postId, data) => {
    const postExists = await prisma.exists.Post({ id: postId })

    if (!postExists) throw new Error('Post not found') 

    const post = await prisma.mutation.updatePost({
        data,
        where: {
            id: postId
        }
    }, '{ author { id name email posts { id title published } } }')
    return post.author
}

/*updatePostForUser('ck158kydw00130778f4yhktj0', {
    published: true, 
    body: 'This is the body of the New Post Modified'
}).then(user => console.log(JSON.stringify(user, undefined, 2)))
.catch(error => console.log(error.message))*/
